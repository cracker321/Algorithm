# [ 재귀함수 Recursive Function ]
'''
- 자기 자신을 다시 호출하는 함수
- 재귀함수를 문제풀이에서 사용할 때는 반드시 재귀함수의 종료조건을 명시해야 함.
  종료조건을 제대로 명시하지 않으면 함수가 무한히 호출될 수 있음
- 재귀함수는 '스택'과 그 원리가 동일하다! 교재 설명 참조하기!

- 재귀함수를 잘 활용하면 복잡한 알고리즘을 간결하게 작성할 수 있음.
  단, 오히려 다른 사람이 이해하기 어려운 형태의 코드가 될 수도 있으므로 신중하게 사용해야 함.
- 모든 재귀함수는 반복문을 사용하여 동일한 기능을 구현할 수 있음.
- 재귀 함수가 반복문보다 유리한 경우도 있고, 불리한 경우도 있음.
- 컴퓨터가 함수를 연속적으로 호출하면 컴퓨터 메모리 내부의 스택 프레임에 쌓임
  그래서, 스택을 사용해야 할 때, 구현상 스택 라이브러리 대신에 재귀함수를 이용하는 경우가 많음.

'''

# # < 일반적인 재귀함수 >
# def recursive_function():
#     print('재귀함수를 호출합니다.')
#     recursive_function()
    

# # '재귀함수 recursive_function()' 호출
# recursive_function()


# < 종료조건을 제대로 명시한 재귀함수 예제 >
def recursive_function(i):
    
    # 100번째 호출했을 때 종료되도록 재귀함수 종료조건 명시 
    # 재귀함수가 특정 시점에 종료되도록 하려면, 이처럼 재귀함수의 '시작 부분'에 if문 등올 재귀함수 종료조건 명시해야 함.
    if i == 100:
        return   # 즉, i = 100 일때, 이 함수는 return문을 만남으로써 종료됨. 
    print(i, '번째 재귀함수에서', i+1, '번째 재귀함수를 호출합니다.')
    recursive_function(i+1) # i=99일 때, i+1=100 이므로, 재귀로 recursive_function(100)이 실행되는데, 이거는 실행되자마자 종료조건 if == 100: return 에 막혀서 함수 종료되고,
                            # 기존에 호출된 i=99로 돌아가서, 바로 아래 실행문으로 내려가서
    print(i, '번째 재귀함수를 종료합니다.') # print(99, '번째 재귀함수를 종료합니다') 가 실행되는 것이다.
                                          # i=99일 때가 종료되면, 그 이전에 호출된 기존의 아직 살아있고 실행, 진행 중인 i=98일 때 토대 위에 i=99가 스택처럼 쌓여졌던 것이니, i=99일 때가 종료되었으니,
                                          # 이제 i=98일 때로 돌아와서, '98번째 재귀함수를 종료합니다.'가 실행되고,
                                          # i=98일 때가 종료되면, 그 이전에 호출된 기존의 아직 살아있고 실행, 진행 중인 i=97일 때 토대 위에 i=98이 스택처렴 쌓여졌던 것이니, i=98d일 때가 종료되었으니,
                                          # 이제 i=97일 때로 돌아와서, '97번째 재귀함수를 종료합니다.'가 실행된다.
                                          
    
recursive_function(1)



# < '번째 재귀함수를 종료합니다'에 대한 chatGPT 설명 >

'''
재귀함수의 호출 과정에서는, 현재 실행되고 있는 함수의 실행 중간에 다른 함수를 호출하는 구문이 있으면, 호출된 함수의 실행이 끝날 때까지 호출한 함수의 실행은 잠시 멈추고 기다립니다.

즉, 98 번째 재귀함수에서 recursive_function(99) 구문을 실행하면, 현재 실행되고 있는 98 번째 재귀함수의 실행은 잠시 중단됩니다. 대신에 recursive_function(99)가 호출되어서, 새로운 99 번째 재귀함수의 실행이 시작됩니다.

그런데 99 번째 재귀함수는 if i == 100: return 구문을 만나면, 함수 실행을 종료하게 됩니다. 따라서 99 번째 재귀함수에서는 다음과 같은 출력문이 실행되고 바로 함수가 종료됩니다.

Copy code
99 번째 재귀함수에서 100 번째 재귀함수를 호출합니다.
그리고 99 번째 재귀함수의 실행이 종료되면, 이전에 중단된 98 번째 재귀함수의 실행이 다시 이어서 실행됩니다. 즉, recursive_function(99) 구문 다음에 실행되어야 할 구문인 print(i, '번째 재귀함수를 종료합니다.')가 실행되면서, 98 번째 재귀함수의 실행이 완전히 종료되고, 다음과 같은 출력문이 출력됩니다.

Copy code
98 번째 재귀함수를 종료합니다.
이렇게 되면 "98 번째 재귀함수에서 99 번째 재귀함수를 호출합니다."와 "98 번째 재귀함수를 종료합니다." 라는 출력문이 순서대로 출력됩니다.



97 번째 재귀함수를 종료합니다:

97번째 재귀함수에서는 다시 한번 재귀함수를 호출하고, 호출된 재귀함수가 종료되면 이어서 자신도 종료됩니다.
따라서 97번째 재귀함수에서는 98번째 재귀함수를 호출한 후에, 다음 문장으로 넘어갑니다.
이 문장은 "print(i, '번째 재귀함수를 종료합니다.')"입니다. 현재 i의 값은 97이므로, 이 문장을 실행하면 "97 번째 재귀함수를 종료합니다." 라는 출력값이 나타납니다.
96 번째 재귀함수를 종료합니다:

96번째 재귀함수에서는 다시 한번 재귀함수를 호출하고, 호출된 재귀함수가 종료되면 이어서 자신도 종료됩니다.
따라서 96번째 재귀함수에서는 97번째 재귀함수를 호출한 후에, 다음 문장으로 넘어갑니다.
이 문장은 "print(i, '번째 재귀함수를 종료합니다.')"입니다. 현재 i의 값은 96이므로, 이 문장을 실행하면 "96 번째 재귀함수를 종료합니다." 라는 출력값이 나타납니다.
이와 같이, 이후의 재귀함수 호출 및 종료 과정도 위와 비슷한 방식으로 이루어집니다.



앞서 설명드린 것과 같이, 97번째와 96번째 재귀함수의 종료과정은 다음과 같습니다.

97 번째 재귀함수를 종료합니다.

: 97번째 재귀함수에서는 다시 한번 재귀함수를 호출한 후에 다음 문장으로 넘어갑니다.

"print(i, '번째 재귀함수를 종료합니다.')" 이 문장을 실행합니다. 현재 i의 값은 97이므로 "97 번째 재귀함수를 종료합니다." 라는 출력값이 나타납니다.
97번째 재귀함수는 이제 종료되었습니다. 이어서 96번째 재귀함수로 돌아갑니다.


96 번째 재귀함수를 종료합니다.

: 96번째 재귀함수에서는 다시 한번 재귀함수를 호출한 후에 다음 문장으로 넘어갑니다.

"print(i, '번째 재귀함수를 종료합니다.')" 이 문장을 실행합니다. 현재 i의 값은 96이므로 "96 번째 재귀함수를 종료합니다." 라는 출력값이 나타납니다.
96번째 재귀함수는 이제 종료되었습니다. 이어서 95번째 재귀함수로 돌아갑니다.

이와 같이, 97번째와 96번째 재귀함수는 각각 자신의 재귀호출 이후에 "print(i, '번째 재귀함수를 종료합니다.')" 문장을 실행하여 각각 "97 번째 재귀함수를 종료합니다."와 "96 번째 재귀함수를 종료합니다." 라는 출력값을 만들어냅니다. 이후에는 이러한 과정이 반복되면서 모든 재귀함수가 순차적으로 종료되게 됩니다.
'''