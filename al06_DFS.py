# [ DFS(Depth-First Search) 깊이우선탐색 ]

'''
파이썬의 리스트 = 자바의 배열

- DFS는 한 번 방문한 노드를 다시 방문하면 안 되므로, 노드 방문 여부를 체크할 방문 리스트 필요하며, 그래프는 인접 리스트로 표현함. 
- DFS의 탐색 방식은 후입선출 특성을 가지므로 스택을 사용하여 설명함.
- 다만, DFS 구현은 스택보다는 스택 성질을 갖는 재귀 함수로 많이 구현함. 


2. 스택에서 노드를 꺼낸 후 꺼낸 노드의 인접 노드를 다시 스택에 삽입하기
  - pop을 수행하여 이제 막 방문한 노드를 스택으로부터 꺼낸 후, 그 노드 근처에 방문해야 할 인접노드가 뭐가 있는지 확인하는 단계
  - 이제 그 인접노드를 스택에 삽입하는 것 

3. 스택 자료구조에 값이 없을 때까지 반복하기
  - 앞의 과정을 스택 자료구조에 값이 없을 때까지 반복함. 이 때, 다녀간 노드는 방문배열 바탕으로 재삽입하지 않는 것이 핵심임!

'''

# [] 백준 11724번. 문제 23: 방향 없는 그래프가 주어졌을 대 연결 요소(connected components)의 개수를 구하는 프로그램을 작성하시오 ]
'''
문제: 방향 없는 그래프가 주어졌을 때 연결 요소의 개수를 구하는 프로그램을 작성하시오. 

입력: 1번째 줄에 노드의 개수 N(1<=N<=1000)과 에지의 개수 M(0<=M<=N*(N-1)/2), 2번째 줄부터 M개의 줄에 에지의 양끝 점 u와 v가 
주어진다(1<=u, v<=N, u와 v는 같지 않다).  같은 에지는 한 번만 주어진다.

출력: 첫째 줄에 연결 요소의 개수를 출력한다.
'''

# 해설: 
# https://www.youtube.com/watch?v=Y2kHlj7xqfU&list=PLFgS-xIWwNVU_qgeg7wz_aMCk22YppiC6&index=13&ab_channel=%ED%95%98%EB%A3%A8%EC%BD%94%EB%94%A9  또는 교재 p139
# https://www.youtube.com/watch?v=yvWmjljjYJY&ab_channel=%EC%BD%94%EB%8D%B0%ED%92%80 

'''
# 수도코드 작성. 교재 p 139~

==============================================================================================
n(노드 개수) m(에지 개수)
A(그래프의 데이터를 저장해주는 인접리스트) 초기화
visited(방문기록 리스트) 초기화

# DFS 구현

DFS:
    visited 리스트에 현재 노드 방문 기록
    현재 노드의 연결 노드 중 방문하지 않은 노드로 DFS를 실행('재귀함수' 형태)
    
for m의 개수 만큼 반복:
    '인접 리스트 A'에 그래프 데이터 저장
    
for n의 개수 만큼 반복:
    if 방문하지 않은 노드가 있으면:
        연결요소 개수의 값 1 증가
        DFS 실행
        
연결 요소의 개수 값 출력    
==============================================================================================

# 해설:
- '연결 요소'란, '에지로 연결된 노드들의 집합'임.
- 모든 노드를 탐색하는 데 실행한 DFS의 실행 횟수 = 연결 요소의 개수
  즉, '한 번의 DFS가 끝날 때까지 탐색한 모든 노드들의 집합 하나'를 '하나의 연결 요소'로 판단할 수 있음.
  따라서, 만약에 그래프가 모두 연결되어 있었다면(노드들이 모두 연결되어 있었다면), DFS는 딱 1번만 실행되었을 것임.

- 1 --> 2 --> 5 : DFS 1회차. 이게 하나의 연결요소 집합
  이후, 이제 방문하지 않았던 3번 노드로 가는 것임.
- 3 --> 4 --> 6 : DFS 2회차. 이게 하나의 연결요소 집합

- 연결된 노드 중 방문하지 않은 노드가 여러 개라면, 그 중 아무 노드나 갈 수 있음.

'''



# < 정답 코드 >


# 1.< 모듈 sys 불러오기 및 관련 세팅 >
import sys # 'sys 모듈'을 가져와서
sys.setrecursionlimit(1000) # 프로그램의 재귀 제한을 1000으로 설정함. 재귀 제한이란, 함수에서 자기 자신을
                             # 호출할 수 있는 최대 횟수를 제한하는 것.
input = sys.stdin.readline # 'input()' 대신, 'sys.stdin.readline()'을 사용하여 입력 속도를 빠르게 함.




# 2.< 입력할 노드의 개수 n과 에지의 개수 m을 입력할 map()함수와 그것을 받아줄 변수 n, m 정의 >
n, m = map(int, sys.stdin.readline().split()) # 입력받은 두 개의 정수를, 변수 n과 변수 m에 할당함. 
                                 # 이 때, 'map()'을 사용하여 입력받은 문자열을 정수형으로 변환함.
                                 
                                 
            
                                 
# 3.< 노드들의 정보를 입력할 '인접리스트 A'를 생성하여 초기화함. >     
# -'인접리스트 A'를 생성하여 여기에 '특정 노드와 연결되어 있는 노드들이 담길 빈 인접리스트 A'를 생성함.                           
A = [[] for _ in range(n+1)] # '인접리스트 A'를 생성하여 초기화함. 노드가 1 부터 시작하기에, 'n+1'까지로 설정함.
                             # 인접리스트 A 내부에 '빈 리스트 []'를 n 개 생성하는 것.
                             # 즉, A = [[], [], [], [], [], [] ...] 와 같은 출력값이 나온다.




# 4.< 방문한 노드인지 여부를 True, False로 판단하는 boolean 리스트를 생성함 >
visited = [False]*(n+1) # - 만약, n이 5인 경우, '변수 visited'는 다음과 같이 초기화됨.
                        # visited = [False, False, False, False, False, False]
                        # -여기서 'n+1'인 이유는, 노드 번호가 1부터 시작하기 때문임.




# 5.< 저~ 아래 7번에서 사용할 DFS(v) 함수를 정의 >
def DFS(v): # 최초 시작 노드번호 v를 임의로 설정하여 인자값으로 받음.
  visited[v]= True # 현재 탐색(방문)하는(방문 중인) '노드 v'를 방문했음을 표시하는 부분. 
  for i in A[v]: # -'인접리스트 A'는 '노드들 간의 연결 정보를 담은 리스트'임. 
                 # -'A[v]': '노드 v'와 연결된 노드들의 리스트를 의미.
                 #   e.g) A[0] = '' / A[1] = 2, 3 / A[2] = 1, 3 / A[3] = .... 
                 #   따라서, A[1]일 경우, '변수 i'에는 2와 3이 차례로 들어가게 됨.
    if not visited[i]: # -'리스트 visited'는 그 원소가 'True' 또는 'False'로 이루어진 'boolean 리스트'이다!
                       # -만약, '노드번호 i'가 아직 방문되지 않았다면(visited[i]가 'False'라면), 
      DFS(i) # 방문하지 않은 그 노드를 시작으로 다시 DFS함수를 호출함.
             # DFS함수를 재귀적으로 호출하며(DFS함수는 '재귀함수'이다!!), '노드번호 i'를 방문하러 감. 
             # 이렇게 하면, '현재 위치의 노드 v와 연결된 노드들 모두 방문'하고, 
             # 이어서 그 노드들과 연결된 노드들도 모두 방문하는 과정이 되게 된다. 
             # 이게 바로 DFS 1회차(= 하나의 연결 요소 집합)가 되게 된다.
            
            
            
            
# 6.< 에지 정보 및 개별 노드에 연결된 노드들을 '인접리스트 A'에 입력(담음) >
'''
에지에 대한 정보를 입력받는 이유는, 그래프를 구성하기 위함임. 
그래프는 노드와 이들을 연결한 에지들로 구성되어 있고, 노드와 에지의 연결 관계를 알지 못하면 그래프 정보를 완전히 이해할 수 없음.
그리고, 이렇게 완성된 그래프를 바탕으로, 문제에서 질문하는 '총 연결 요소 (집합) 개수'를 구할 수 있게 되는 것이다!
'''
            
for _ in range(m): # 에지(간선)의 정보를 입력받는 부분임. 'm'은 에지(간선)의 개수를 의미함.
  s, e = map(int, sys.stdin.readline().split()) # 두 개의 정수값을 입력받아, 변수 s와 변수 e에 저장함.
                                                # 이 두 정수값은 '에지의 시작점(노드)과 끝점(노드)'을 의미.
  
  # '양방향 그래프의 연결 정보(=에지 정보) 저장. '양방향(무방향) 에지'이므로 양쪽 노드 모두에 에지를 더하기
  A[s].append(e) # 만약, s=1, e=3 이라면, '노드 1번(=A[1])'에 연결된 '3번 노드'와의 연결 에지(1번 노드와 3번 노드를 연결하는 에지)를 인접 리스트에 추가하는 것.
  A[e].append(s) # 동일하게, s=3, e=1 일때의, '노드 3번(=A[3])'에 ...
                 # 'gr43_adjacent_matrix.py' 참고하기!
  
  
  
  
# 7.< 자, 이제 위에서 완성된 그래프의 전체 노드들을 이제 처음부터 '1번 노드부터(처음부터)' 순회하면서
#     (위에서 '이제 아래에서 입력될 노드들을 담을 빈 인접리스트 A'와 '전체 에지 정보'가 입력되었으니), 
#     이제 이 그래프에서 연결된 모든 노드들을 찾아내는 것 >
# -즉, '총 연결 요소 (집합) 개수'를 확인하는 단계임.  

count = 0 # '연결 요소 (집합)'의 개수를 세는 변수. 즉, DFS를 몇 회차까지 실행했는지를 카운트하는 변수. 이것을 일단 초기화함.

for i in range(1, n+1): # 1번 노드부터 n번 노드까지 모든 노드를 순회하는 부분. 'n'은 '노드의 개수'를 의미함.
                        # cf) 'for i in range(1, n+1)': 1부터 n까지의 정수를 변수 i에 차례대로 대입하는 것.
                        #     'for i in range(n+1)': 0부터 n까지의 정수를 변수 i에 차례대로 대입하는 것.
  if not visited[i]: # 최초 시작 노드에서 시작하여, 그것과 연결 노드 중 방문하지 않았던 노드를 찾아낸다면, 
                     # ( 만약 방문하지 않은 노드라면('visited[i]'가 False인 노드), 'if not'은 'True가 되어', 
                     # 바로 아래 실행문들을 수행함.
                     # '리스트 visited'는 그 원소가 'True'또는 'False'로만 이루어진 'boolean 리스트'이다! )
    count += 1 # 'count'를 1 증가시킴. 왜냐하면, 방문하지 않은 노드를 찾았다는 것은, '새로운 연결 요소 (집합)'을 찾았다는 것을 의미함.
               # 가장 첫 번째
               # ( 방문하지 않았던 노드를 새롭게 방문하는 것이기 때문에, 그 노드가 속한 '연결 요소 (집합)'이 발견된 것이고
               # 이에 따라, '총 연결 요소 (집합) 개수'는 당연히 1개 증가하는 것이 된다! )
    DFS(i) # '새롭게 발견한 연결 요소 (집합)' 내부의 '현재 방문한 노드 i'를 시작점으로 DFS를 실행하는 코드임.
           # 이렇게 하면, i와 연결된 노드들을 모두 방문하고, 이어서 그 노드들과 연결된 노드들도 모두 방문하는 과정을 반복하게 됨.
           # 해당 노드번호 i부터 시작한 DFS가 종료되면, 이는 노드번호 i가 속한 연결 요소 (집합) 내의 모든 노드들을 모두 방문 완료한 것임. 
           # 그리고, 이제 다음 노드를 찾아 같은 과정을 반복할, 반복하는 것임.
    
    
    
    
# 8.< 최종의 '총 연결 요소 (집합) 개수를 출력함 >    
print(count)

