# [ implementation ]

# [ 소가 길을 건너간 이유 1 ]. 백준 14467번. 브론즈
# https://www.acmicpc.net/problem/14467



# =============================================================================================


N = int(input()) # 소 관찰 횟수 N을 입력받음.
cows = {} # 소의 번호와 위치를 저장하기 위한 빈 딕셔너리를 생성 및 초기화
cnt = 0 # 길을 건넌 소들의 최소 횟수를 저장할 변수 cnt 생성 및 초기화


for _ in range(N):
    cnumber, clocation = map(int, input().split()) # 한 줄에 소의 번호와 위치를 입력받음.
    
    if cnumber not in cows: # 만약, 입력된 소의 번호가 기존의 딕셔너리에 없다면,
        cows[cnumber] = clocation # 딕셔너리에 소의 번호와 위치를 저장함.
    else: # 만약, 입력된 소의 번호가 딕셔너리에 있다면,
        if cows[cnumber] != clocation: # 만약, 이미 딕셔너리에 소의 번호 및 그에 대응하는 소의 위치가 존재하고, 
                                       # 기존의 위치가 새롭게 입력된 소의 위치와 다르다면,
            cnt += 1 # 소가 길을 건넌 횟수를 1 증가시킴.
                     # 기존과 새롭게 입력된 소의 위치가 다르므로, '소가 길을 건넜다고 판단하여' cnt값을 1 증가시킴.
            cows[cnumber] = clocation # 딕셔너리에 소의 번호와 위치를 업데이트함.
            
    print(cnt)
    
    '''
cf)
- 딕셔너리에서 '키(cnumber)'와 '값(clocation)' 중에서 '값(clocation)'을 '꺼내는' 방법
  : cows[cnumber]
  
- 기존의 딕셔너리에 새로운 '키(cnumber)'와 '값(clocation)'을 '추가'하는 방법
  : cows[cnumber] = clocation
'''
        

# =============================================================================================

# < 위와 같은 코드이지만, 좀 다 내가 자세히 설명한 것 >

N = int(input())

# 소의 번호와 위치로 이루어져 있으니 --> 한 쌍 --> 딕셔너리 자료형 사용. '소의 위치와 번호 대한 정보 전체'를 뜻하는 변수명 cows 로 설정
cows = {}

# 소가 길을 건너간 최소 횟수를 출력해야 하나, 그 횟수를 카운팅하는 변수 cnt 생성 및 초기화
cnt = 0


for _ in range(N): # '예제 입력'에서처럼 입력되는 줄의 개수가 N개가 되니, 이렇게 for문 써야 함.
    cnumber, clocation = map(int, input().split()) # 소의 번호와 위치를 입력받고, 그것을 공백 띄워서 나눔.
    
    if cnumber not in cows: # 만약, 새롭게 입력되는 소의 번호가 기존의 딕셔너리에 없다면,
        cows[cnumber] = clocation # 새롭게 입력되는 소의 번호와 위치를 기존의 딕셔너리에 추가하고, : 딕셔너리에 새로운 원소 키, 값 추가하는 방법 참고.
    else: # 만약, 새롭게 입력되는 소의 번호가 기존의 딕셔너리에 있다면,
        cows[cnumber] != clocation # 또한, 새로운 입력으로 들어온 소의 위치('cows[number]')가 기존의 소의 위치('clocation')과 다르다면,
        cnt += 1 # 소가 이동한 것이 되므로, 소의 이동 횟수를 하나 늘려줌
        
        cows[cnumber] = clocation # 기존의 딕셔너리에 새로운 입력으로 들어온 소의 번호와 위치를 입력 및 업데이트 해줌.
        
print(cnt) # 소가 길을 건넌 횟수인 cnt를 출력함


# =============================================================================================

'''
    
< 정답코드 1 >

n=int(input())
cows={}
cnt=0
for _ in range(n):
    a,b=map(int,input().split())
    if a not in cows:
        cows[a]=b
    else:
        if cows[a]!=b:
            cnt+=1
            cows[a]=b
print(cnt)

'''

# =============================================================================================

'''
< 정답코드 2 >


    
'''

# =============================================================================================



""" 
문제
: 닭이 길을 건너간 이유는 과학적으로 깊게 연구가 되어 있지만, 의외로 소가 길을 건너간 이유는 거의 연구된 적이 없다. 
이 주제에 관심을 가지고 있었던 농부 존은 한 대학으로부터 소가 길을 건너는 이유에 대한 연구 제의를 받게 되었다.

존이 할 일은 소가 길을 건너는 것을 관찰하는 것이다. 존은 소의 위치를 N번 관찰하는데, 각 관찰은 소의 번호와 소의 위치 하나씩으로 이루어져 있다. 
존은 소를 10마리 가지고 있으므로 소의 번호는 1 이상 10 이하의 정수고, 소의 위치는 길의 왼쪽과 오른쪽을 의미하는 0과 1 중 하나다.

이 관찰 기록을 가지고 소가 최소 몇 번 길을 건넜는지 알아보자. 
즉 같은 번호의 소가 위치를 바꾼 것이 몇 번인지 세면 된다.


입력
: 첫 줄에 관찰 횟수 N이 주어진다. N은 100 이하의 양의 정수이다. 
다음 N줄에는 한 줄에 하나씩 관찰 결과가 주어진다. 관찰 결과는 소의 번호와 위치(0 또는 1)로 이루어져 있다.


출력
: 첫 줄에 소가 길을 건너간 최소 횟수를 출력한다.


예제 입력 1 
8
3 1
3 0
6 0
2 1
4 1
3 0
4 0
3 1
예제 출력 1 
3
힌트
3번 소는 위치 1, 0, 1에서 관찰되었으므로 길을 최소 두 번 건넜음을 확인할 수 있다. 4번 소도 길을 한 번 건넜으며, 나머지 소는 길을 건넌 기록이 확인되지 않는다.


"""