# [ implementation ]

# [ 줄세우기 ]. 백준 10431번. 브론즈
# https://www.acmicpc.net/problem/10431






# ===================================================================================================================


P = int(input().strip())

for _ in range(P):
    cnt = 0 # '변수 cnt'는 반드시 테스트케이스마다 초기화되어야 한다!
            # 왜냐하면, 테스트케이스를 이 위치가 아닌 for문 외부('P=int(input().strip())' 바로 아래 부분)에 위치시킬 경우,
            # for문으로 첫 번째 테스트케이스 돌린 후 결과로 나온 cnt 값이, 이후의 두 번째 테스트케이스 돌릴 때의 최초 cnt 값으로
            # 들어가게 됨. 
            # 이를 방지하기 위해 매 케이스마다 cnt=0으로 초기화가 되어야 하기 때문에, 여기에 위치시킨다!
    T, *list = map(int, input().strip().split()) # list(...)로 감싸줘도 상관없음. 결과는 동일함.
    
    for j in range(20):
        for k in range(j+1, 20): # 인덱스번호 자체가 0번부터 시작하기 때문에, '인덱스 20번까지'는 당연히 0~19번까지 총 20명을 뜻하는 것임. 당연.. 
            if list[j] > list[k]:
                list[j], list[k] = list[k], list[j]
                cnt += 1
    
    print(T, cnt)
    
    
    
    
    


# ===================================================================================================================

'''
문제
초등학교 선생님 강산이는 아이들을 데리고 단체로 어떤 일을 할 때 불편함이 없도록 새로 반에 배정받은 아이들에게 키 순서대로 번호를 부여한다. 
호를 부여할 땐 키가 가장 작은 아이가 1번, 그 다음이 2번, ... , 가장 큰 아이가 20번이 된다. 
강산이네 반 아이들은 항상 20명이며, 
다행히도 같은 키를 가진 학생은 한 명도 없어서 시간이 조금 지나면 아이들은 자기들의 번호를 인지하고 한 줄로 세우면 제대로 된 위치에 잘 서게 된다.

하지만 매년 첫 며칠간 강산이와 강산이네 반 아이들은 자기가 키 순으로 몇 번째인지 잘 알지 못해 아주 혼란스럽다. 
자기 위치를 찾지 못하는 아이들을 위해 강산이는 특별한 방법을 생각해냈다.

우선 아무나 한 명을 뽑아 줄의 맨 앞에 세운다. 그리고 그 다음부터는 학생이 한 명씩 줄의 맨 뒤에 서면서 다음 과정을 거친다.

자기 앞에 자기보다 키가 큰 학생이 없다면 그냥 그 자리에 서고 차례가 끝난다.
자기 앞에 자기보다 키가 큰 학생이 한 명 이상 있다면 그중 가장 앞에 있는 학생(A)의 바로 앞에 선다. 
이때, A부터 그 뒤의 모든 학생들은 공간을 만들기 위해 한 발씩 뒤로 물러서게 된다.
이 과정을 반복하면 결국 오름차순으로 줄을 설 수가 있다.

아이들의 키가 주어지고, 어떤 순서로 아이들이 줄서기를 할 지 주어진다. 
위의 방법을 마지막 학생까지 시행하여 줄서기가 끝났을 때 학생들이 총 몇 번 뒤로 물러서게 될까?


입력
: 첫 줄에 테스트 케이스의 수 P (1 ≤ P ≤ 1000) 가 주어진다.
각 테스트 케이스는 테스트 케이스 번호 T와 20개의 양의 정수가 공백으로 구분되어 주어진다.
20개의 정수는 줄서기를 할 아이들의 키를 줄서기 차례의 순서대로 밀리미터 단위로 나타낸 것이다.
모든 테스트 케이스는 독립적이다.


출력
: 각각의 테스트 케이스에 대해 테스트 케이스의 번호와 학생들이 뒤로 물러난 걸음 수의 총합을 공백으로 구분하여 출력한다.


예제 입력 1 
4
1 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919
2 919 918 917 916 915 914 913 912 911 910 909 908 907 906 905 904 903 902 901 900
3 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 900
4 918 917 916 915 914 913 912 911 910 909 908 907 906 905 904 903 902 901 900 919


예제 출력 1 
1 0
2 190
3 19
4 171


'''


# ===================================================================================================================

# < 정답코드 1 >

t = int(input())

for i in range(t):
    cnt = 0 # '변수 cnt'는 반드시 테스트케이스마다 초기화되어야 한다!
            # 왜냐하면, 테스트케이스를 이 위치가 아닌 for문 외부('P=int(input().strip())' 바로 아래 부분)에 위치시킬 경우,
            # for문으로 첫 번째 테스트케이스 돌린 후 결과로 나온 cnt 값이, 이후의 두 번째 테스트케이스 돌릴 때의 최초 cnt 값으로
            # 들어가게 됨. 
            # 이를 방지하기 위해 매 케이스마다 cnt=0으로 초기화가 되어야 하기 때문에, 여기에 위치시킨다!
    n, *arr = map(int, input().split()) # 입력된 것들 중에 첫 번째 원소(케이스 번호)는 변수 n에 할당되고
                                       # 그 이후 입력된 원소들 전체(입력되는 원소 개수가 고정적인 경우에만 '*'를 사용 가능)는 변수 arr에 할당됨.
                                       # eg) 예제입력에서 입력값으로 들어온 "2 900 901 902 903 904 905 ... 919"의 경우,
                                       # '2'는 변수 n에 할당되고,
                                       # 그 이외 '900 901 902 ... 919'는 전부 변수 arr에 할당됨.
                                       # -변수가 2개이기 때문에, list(map(int, input().strip().split())) 해줘도 상관없음. 결과 동일

    for j in range(20):
        for k in range(j+1,20): # 인덱스번호 자체가 0번부터 시작하기 때문에, '인덱스 20번까지'는 당연히 0~19번까지 총 20명을 뜻하는 것임. 당연.. 
            if arr[j] > arr[k]: # 앞에 있는 학생의 키가 뒤에 있는 학생의 키보다 큰 경우
                cnt += 1
                arr[j], arr[k] = arr[k], arr[j] # '서로 자리를 바꾸기 때문'에, 앞 뒤 번호 둘 다의 위치를 바꿔줘야 한다.
                                                # 따라서, 둘 다 변경해줘야 함.

    print(n, cnt)

'''
< 여기서 '중첩된 for문'을 사용하는 이유 >
- '버블 정렬(Bubble Sort)': 인접한 두 항목을 비교하여 필요에 따라 위치를 교환하고자 할 때 사용함.
                           '중첩된 for문'은 정렬 알고리즘 중 하나인 '버블 정렬'을 구현하기 위해 사용됨.
- 여기서의 '중첩된 for문'은 '모든 학생 쌍을 순차적으로 비교하여 정렬'하는 역할.
  (1) 모든 조합의 쌍 검토: 모든 가능한 배열 내의 학생 쌍을 검토하여 정렬 알고리즘이 적절하게 작동할 수 있도록 함.
  (2) 간소화: 중첩된 for문을 사용함으로써, 비교하는 두 학생의 모든 가능한 조합에 대해 간단하고 직관적인 방법으로 접근할 수 있음.
  (3) 시간 복잡도: 중첩된 for문은 알고맂므의 시간 복잡도를 O(n^2)으로 만든다. 문제에서 주어진 경우와 같이 배열의 크기가 작거나
                  입력값이 제한된 경우에는 전체 실행 시간이 효율적임.
                  
- '외부 for문'은 '현재 학생을 나타내는 인덱스를 순차적으로 선택'하고,
  '내부 for문'은 '현재 학생의 '다음 학생부터 마지막 학생까지'를 순차적으로 선택'함.
- '외부 for문'은 한 번 반복될 때마다 현재 학생과 그 이후의 모든 학생들과의 비교를 수행하며(=현재 학생이 반복의 대상이 됨),
  '내부 for문'은 현재 학생의 다음 학생부터 마지막 학생까지가 그 반복의 대상이 됨.    
- 즉, 현재 학생보다 큰 키를 가진 학생을 찾으면, 그 뒤의 모든 학생들과 위치를 교환함.               


'''


# ===================================================================================================================

for _ in range(int(input())):
    a, *arr = map(int, input().split())
    cnt = 0
    for i in range(19):
        for j in range(19-i):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
                cnt += 1
    print(a,cnt)
    
    
# ===================================================================================================================

T = int(input())
for _ in range(T):
    sum = 0
    temp = list(map(int, input().split()))
    N, num = temp[0], temp[1:]
    
    for i in range(20):
        for j in range(i):
            if num[j] > num[i]:
                sum += 1
    print(N, sum)


# ===================================================================================================================


# < 내 오답코드 >

P = int(input())

cnt = 0

for i in range(P):
    temp = list(map(int, input().strip().split()))

    for i in range(2, len(temp)-1):
        if temp[i] > temp[i+1]:
            temp[i+1] = temp[i]
            
            cnt += 1
    print(i + cnt)