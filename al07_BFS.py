# [ BFS(Breadth First Search) 깊이우선탐색 ]
# 강의 https://www.youtube.com/watch?v=Cs8DaupoSPM&list=PLFgS-xIWwNVX-zm4m6suWC9d7Ua9z7fuT&index=23
'''
- 큐 자료구조 사용
- FIFO(선입선출)
- 탐색 시작 노드와의 가까운 노드를 우선하여 탐색하므로, 목표 노드에 도착하는 경로가 여러 개일 때, 최단 경로를 보장함.
- DFS, BFS 모두 '(노드, 에지 관계가 있는)그래프'가 주어지면, 이를 '인접 리스트'로 바꾼다!
'''

# [ 백준 1260번 ]
'''
문제: 그래프를 DFS로 탐색한 결과와 BFS로 탐색한 결과를 출력하는 프로그램을 작성하시오. 
단, 방문할 수 있는 정점이 여러 개인 경우에는 정점 번호가 작은 것을 먼저 방문하고, 더 이상 방문할 수 있는 점이 없는 경우 종료한다. 
정점 번호는 1번부터 N번까지이다.

입력: 첫째 줄에 정점의 개수 N(1 ≤ N ≤ 1,000), 간선의 개수 M(1 ≤ M ≤ 10,000), 탐색을 시작할 정점의 번호 V가 주어진다. 
다음 M개의 줄에는 간선이 연결하는 두 정점의 번호가 주어진다. 어떤 두 정점 사이에 여러 개의 간선이 있을 수 있다. 
입력으로 주어지는 간선은 양방향이다.

출력: 첫째 줄에 DFS를 수행한 결과를, 그 다음 줄에는 BFS를 수행한 결과를 출력한다. V부터 방문된 점을 순서대로 출력하면 된다.
'''

#============================================================================================================================

# [ DFS ]

# 1.< 그래프 입력받기 >


# 1-1.< 노드의 개수 n, 에지의 개수 m, 시작노드 번호 v 를 먼저 입력받은 후에, 비로소 그래프 구성이 시작된다 >
# -입력받은 값을 map() 함수를 사용하여 정수형으로 변환하여 각 변수에 저장함.
import sys
n, m, v = map(int, sys.stdin.readline().split())



# 1-2.< 특정 노드와 연결되어 있는 노드들이 담길 빈 인접리스트 graph를 생성 >
# -'빈 리스트 []'를 'n+1'개 만큼 생성함. 왜냐하면, 노드번호는 관례적으로 1번부터 시작하고, 따라서 '없는 노드번호 0번에 연결된 없는 노드들이 담기는 빈 리스트'가
#   어쨌든 생성되야 하기 때문이다.
graph = [[] for _ in range(n+1)] 



# 1-3.< 에지 정보 및 개별 노드에 연결된 노드들을 '인접리스트 graph'에 입력(담음) >
for _ in range(m): # 에지의 개수는 처음에 저기 위에서 'm'개로 이미 입력되었기 때문임.
    a, b = map(int, sys.stdin.readline().split())
    graph[a].append(b)
    graph[b].append(a)
    


# 1-4.< '개별 노드에 연결된 노드들이 담긴 인접리스트 A'의 원소들을 오름차순으로 정렬함(문제 조건임) >
# -이는 아래에서 사용될, '함수 DFS'와 '함수 BFS'등 DFS, BFS 알고리즘에서 작은 번호부터 방문할 수 있도록 하기 위함임.
#  따라서, graph[i]의 값들을 ' 함수 sort()'를 사용하여 오름차순 정렬함 
for i in range(1, n+1):
    graph[i].sort()



# 2.< DFS함수 구현 >

# 2-1.< 방문한 노드인지 여부를 True, False로 판단하는 boolean 리스트를 생성함 >
visited = [False]*(n+1) # - 만약, n이 5인 경우, '변수 visited'는 다음과 같이 초기화됨.
                        # visited = [False, False, False, False, False, False]
                        # -여기서 'n+1'인 이유는, 노드 번호가 1부터 시작하기 때문임.



# 5.< 저~ 아래에서 사용할 DFS(v) 함수를 정의 >
def DFS(v):
    visited[v] = True
    result.append(v) # 방문 완료한 노드를 '리스트 result'에 담음.
                     # cf) 암묵적 변수 선언: 파이썬에서는 변수를 선언하지 않고도 값을 할당하고 사용할 수 있음. 
    '''
    e.g) x = 10
    y = 20
    sum = x + y
    print(sum) 
    이렇게 '변수 sum'을 미리 선언하지 않고도 바로 값을 할당해서 사용하는 것이 가능하다!
    '''
    for i in graph[v]: # '함수 DFS(v)'에서 이미 '매개변수 v'가 주어진 상황이기 떄문에, 여기서 'graph[v]'가 말이 되는 것임!
        if not visited[i]:
            DFS(i) # 방문하지 않은 그 노드를 시작으로 다시 DFS함수를 호출함.



#============================================================================================================================

# [ BFS ]


'''
def BFS(v):
    queue = deque([v]) # 현재 정점을 큐에 넣음
    visited[v] = True # 현재 정점을 방문한 것으로 처리
    while queue:
        v = queue.popleft() # 큐에서 하나씩 꺼내면서 방문
        result.append(v) # 방문한 정점을 결과 리스트에 추가
        for i in graph[v]: # 현재 정점과 인접한 정점들을 방문
            if not visited[i]:
                queue.append(i) # 방문하지 않은 정점을 큐에 넣음
                visited[i] = True # 방문한 정점으로 처리'
'''

# < BFS 구현 >
from collections import deque
def BFS(v): # 최초 시작 노드번호 v를 임의로 설정하여 인자값으로 받음.
    visited[v] = True # 현재 방문 중인 노드를 방문 완료로 표시함.
    queue = deque([v]) # 현재 방문 중인 노드를 큐에 넣음. 
                       # 즉, '현재 방문된 노드 v'는 이제 방문완료 된 것이므로, 큐에 넣었고, 따라서 이제 앞으로는 방문되지 않도록 처리한 것임.
    while queue: # 큐 내부에 원소가 존재하면 true를, 원소가 없으면 false를 반환함.
                 # 즉, 큐가 비어 있지 않은 동안, 아래 실행문들을 반복함.
        v = queue.popleft() # 큐의 맨 앞에 있는 즉, 가장 먼저 방문된(가장 먼저 큐에 들어간) 원소(=노드)를 꺼내 v에 할당함. 
                            # 위 순서대로 따라오면 당연한 것임..
                            # -큐의 popleft(): 스택의 pop() 과 동일한 기능임. 큐에 가장 처음에 들어간 맨 앞 원소를 제거하고, 그 제거한 원소를 반환함.
        result.append(v) # 방문 완료한 노드를 '리스트 result'에 집어넣음.
                         # 이렇게 하면, 이제 방문한 순서대로 노드들을 '리스트 result'에 저장함.
        for i in graph[v]: # 현재 노드 v에 인접한 노드들을 하나씩 순회함.
            if not visited[i]: # 현재 노드 v에 인접한 노드들 중 하나인 '노드번호 i'가 아직 방문되지 않은 노드일 경우,
                visited[i] = True # 현재 노드 v에 인접한 노드들 중 하나인 '노드번호 i'를 방문하고, 이것을 방문 완료로 표시함.
                                  # cf) DFS는 재귀적이기 때문에, 여기 위치에서 바로 다시 'DFS(i)'를 호출하지만,
                                  #     BFS는 재귀적이지 않기 때문에, 
                queue.append(i) # 이제는 방문완료 된'노드번호 i'를 이것을 큐에 넣고, 따라서 이제 앞으로는 방문되지 않도록 처리함.



#=======================================================================================================================

# DFS 호출 준비 세팅
visited = [False]*(n+1)              
result = []


# DFS 호출
DFS(v)
print(result)            


# BFS 호출 준비 세팅
visited = [False]*(n+1)
result = []


# BFS 호출
BFS(v)
print(result)
            


